---
title: 'Lecture 4: Non-linear Programing, Constrained Maximization'
jupyter: python3
---

```{python}
#| slideshow: {slide_type: skip}
import pandas as pd
import numpy as np
```



### Items for reiteration:

1. The lecture notes are posted on my website. I've added link to the location at the top of the canvas page.
2. The lectures are not recorded. _New in 2025: I am recording supplemental versions for the add drop period, if these are useful (and time allows) I will continue to make them._
2. Please post your questions about course content on the canvas discussions for each lecture (they go live after the lecture).
3. __Thanks to those of you that have reached out with questions! I enjoy answering them, and it helps me a lot to see what is working and what is not.__
4. The review lectures will address everyone's favorite question: "Dr. Morris, please tell me exactly what will be on the exam."
    - Note: The answer to the most popular questions seems to be: "Focus on setup and interpretation, not calculation."

## A note on incremental cost and marginal cost:

- Marginal Cost: as it's used in economics (i.e. MR=MC under competition) is a mathmatical term: the derivative of the cost function w.r.t. quantity.
- Incremental Cost is a practical term: the change in cost for a one unit change in output.

The two are often interchangable, but we should know that they are different. They are the same when the cost curve is linear, they are intechangable whenever we decide that a linear approximation is suitable for our purposes.

In this exercise, we will use the incremental cost as a simple way to get an idea of how the marginal cost is changing.

## Let's go through the homework:

You manage a two-product firm. The production technology requires a mixture of
capital and labor to produce each product. Capital is shared, while labor is
specific to each of the two products. For the first product, capital ($K \geq
0$) and labor ($L_1 \geq 0$) must satisfy the following, in order to produce
$q_1$ units: $q_{1} \leq \sqrt{KL_{1}}$. Likewise, producing $q_2$ units of the
second product requires capital ($K$) and labor (now $L_2 \geq 0$) such that:
$q_2 \leq\sqrt{KL_2}$. In addition, total capital is limited to a maximum of
200 units. (So $K \leq 200$.) Naturally, $K$, $L_1$, $L_2$ are all required to
be non-negative. Capital costs 100 per unit, labor for the first product costs
140 per unit and labor for the second product costs 175 per unit. The first
product sells for 275 per unit, and the second sells for 300 per unit.

1. Initially suppose only the first product is present. Determine and interpret your optimal production plan.
2. Next suppose only the second product is present. Determine and interpret your optimal production plan.
3. Now assume both products are present. Determine and interpret your optimal production plan.
4. Repeat the three parts above assuming the first product sells for 200 per unit.

5. Fill in the following table:

| $q_1$ | $q_2$ | MC of $q_1$ with $q_2$ fixed. | MC of $q_2$ with $q_1$ fixed. |
|:-----:|:-----:|:-----------------------------:|:-----------------------------:|
|   50  |   50  |                               |                               |
|   50  |  100  |                               |                               |
|   50  |  150  |                               |                               |
|  100  |   50  |                               |                               |
|  100  |  100  |                               |                               |
|  100  |  150  |                               |                               |
|  150  |  100  |                               |                               |
|  150  |  150  |                               |                               |

(_MC is the marginal cost, but for this exercise we can use one unit changes as a proxy for  the marginal cost._)

<!-- ### Three quick points based on common questions:  -->
<!-- 1. The cost of capital is 100 per unit, so if the constraint binds total cost of capital is 100 $\times$ 200 = 20,000 -->
### Q 1: Determine and interpret your optimal production plan.
#### Start by thinking about what $q_{1} \leq \sqrt{KL_{1}}$ and $q_2 \leq\sqrt{KL_2}$ are?

- A name for this sort of function is a "__production function__"

- The expression $q_{1} \leq \sqrt{KL_{1}}$ is the rate at which our production process changes inputs into outputs.

- Notice that this even though there is a $\leq$ sign, that this is not a constraint _per se_ because we get to choose $K$ and $L_1$, and it is only that choice that constrains the amount of $q_1$ that we produce.
- Also notice that if we are trying to optimize we will never produce less than $q_1=\sqrt{KL_{1}}$

Let's look at some plots to see the implications of this.
__Note that I'll use python for the examples today, this is because it makes 3-d plotting easy, and I want you to think of these as list of steps.__

```{python}
#| slideshow: {slide_type: fragment}
# quick set up for our plot
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np

# create the framework for our plot
l1 = np.linspace(0, 300, 300)
k = np.linspace(0, 200, 300)
L1, K = np.meshgrid(l1, k)

# CALCULATE THE PRODUCTION FUNCTION 
Q1 = np.sqrt(L1*K)
```

```{python}
#| slideshow: {slide_type: skip}
# Lets look at the objects we created:
l1[0:10] # first 10 elements of l1
# k[0:10] 
# K
# L1
Q1
```

```{python}
#| slideshow: {slide_type: subslide}
# Create the figure and add a 3D axis
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
# Plot the data
ax.plot_surface(L1, K, Q1)
# Set axis labels and show the plot
ax.set_xlabel('L1')
ax.set_ylabel('K')
ax.set_zlabel('Q1')
plt.show()
```

### What if we hold K fixed? What will the graph look like?

In `Q1 = np.sqrt(L1*K)` we will plug in values for `K` and let `L1` vary.

```{python}
#| slideshow: {slide_type: fragment}
l1 = np.linspace(0, 300, 300)
Q1_10 = np.sqrt(L1*10)    # k = 10
Q1_100 = np.sqrt(L1*100)  # k = 100
Q1_200 = np.sqrt(L1*200)  # k = 200
```

```{python}
#| slideshow: {slide_type: skip}
# Lets look inside Q1 and Q1_10
Q1[0:5]
Q1_10[0:5]
```

### What if we hold K fixed? What will the graph look like?

```{python}
#| slideshow: {slide_type: fragment}
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(L1, K, Q1_10)
ax.plot_surface(L1, K, Q1_100)
ax.plot_surface(L1, K, Q1_200)
ax.set_xlabel('L1')
ax.set_ylabel('K')
ax.set_zlabel('Q1')
plt.show()
```

## Back to the question:

### What is an optimal production plan?

- The one that maximizes profits! 
- Subject to constraints. 
- So the optimal production plan is the ones that maximizes $R-C$ subject to the constraints in the problem.

### Optimal production plan for $q_1$ alone:

Maximize: $ \Pi = R - C $

Let's refer to the prices as "P", and the labor and capital costs as "C"


$$ \Pi(P,C) \equiv P \times q_1 - C_L \times L_1 - C_K \times K $$

Plug in the P's and C's from the problem and then add the production function and capital constraints.

$$ \Pi(P,C) \equiv 275 \times q_1 - 140 \times L_1 - 100 \times K $$
$$ q_1 \leq \sqrt{L_1 \times K} $$
$$ K \leq \bar{K} = 200 $$

This makes it seem like we have more choices than we actually have. The constraint (production function) makes it so that we can only choose two of K, q1, and l1. So we can plug the production function in for labor or quantity (I choose labor to get rid of the sqrt)

$$ \Pi(P,C) \equiv 275 \times q_1 - 140 \times \frac{q_1^2}{K} - 100 \times K $$
$$ K \leq \bar{K} = 200 $$

### So what do we do with this?
$$ \Pi(P,C) \equiv 275 \times q_1 - 140 \times \frac{q_1^2}{K} - 100 \times K $$
$$ K \leq \bar{K} = 200 $$

How do we choose the optimal production plan?

- Guess and check? 
- Set up and solve a Legrangian :) I am not going to ask you to do this... you can do it with Excel and Python!
- Note that you can apply the steps we do here to any similar solver.

__iPRS: How did you solve this?__

## Since this is not a linear problem let's use [GEKKO](https://gekko.readthedocs.io/en/latest/)

(don't worry... we will do this in Excel as well, and the exam will focus on setup and interpretation)

```{python}
#| slideshow: {slide_type: fragment}
# set up the solver
from gekko import GEKKO # pip install gekko... I posted a video about this
m = GEKKO(remote=False) # here we create a gekko object called 'm'
```

### Step 1: Specify the 'Choice Variables' and their constraints

```{python}
#| slideshow: {slide_type: fragment}
# Initialize the decision variables
q1 = m.Var(
    name="q1", 
    lb=0 # the lower bound
) 
q1.value=1 # most solvers run faster when you give a starting point

k =  m.Var(
    name="k", 
    lb=0, # lower bound
    ub=200 # upper bound
) 
k.value=200 # this is our first guess to speed up the solution
```

### Step 2: Write down the objective function (what we want to maximize), any remaining constraints, and solve.
$$ \Pi(P,C) \equiv 275 \times q_1 - 140 \times \frac{q_1^2}{K} - 100 \times K $$
_What happened to $ K \leq \bar{K} = 200 $?_ (hint: it is a constraint on a _choice variable_ look for it on the previous slide!)

```{python}
#| slideshow: {slide_type: fragment}
m.Maximize(
    275*q1 - 140*((q1**2)/k) - 100*k
)
m.solve(disp=False) # silencing the output because it is diagnostic
```

The output from the model is just the choice variables: we need to calculate profit and labor:

```{python}
#| slideshow: {slide_type: fragment}
q1, k
```

We need to calculate profit and labor:

Plug $q_1 = 196.43$ and $K=200$ into $\Pi(P,C) \equiv 275 \times q_1 - 140 \times \frac{q_1^2}{K} - 100 \times K $

Use the production function to calculate $l_1=q_1^2/K$

```{python}
#| slideshow: {slide_type: fragment}
profit = (275*q1.value[0] - 140*((q1.value[0]**2)/k.value[0]) - 100*k.value[0])
l1 = q1.value[0]**2/k.value[0]
```

### This gives us the following solutions 
(note that I'm rounding here)

```{python}
#| slideshow: {slide_type: fragment}
print('q1     ', int(q1.value[0])) # q1 is a list q1[0] is the first element of the list.
print('l1     ', int(l1))
print('K      ', int(k.value[0]))
print('profit ', int(profit))
```

### Optimal production plan for $q_2$ alone:
Let's refer to the prices as "P", and the labor and capital costs as "C"
$$ \Pi(P,C) \equiv  300 \times q_2  - 175 \times L_2 - 100 \times K $$
$$ q_2 \leq \sqrt{L_2 \times K} $$
$$ K \leq \bar{K} = 200 $$

We make a similar substitution here:

$$ \Pi(P,C) \equiv  300 \times q_2  - 175 \times \frac{q_2^2}{K} - 100 \times K $$
$$ K \leq \bar{K} = 200 $$

```{python}
#| slideshow: {slide_type: fragment}
# same set up repeated to clean out 'm'
m = GEKKO(remote=False)
q2 = m.Var(name="q2", lb=0)
q2.value=1 
k =  m.Var(name="k", lb=0, ub=200)
k.value=200 
```

### Write down the objective function again and solve:
$$ \Pi(P,C) \equiv + 300 \times q_2  - 175 \times \frac{q_2^2}{K} - 100 \times K $$

```{python}
m.Maximize(
    300*q2 - 175*((q2**2)/k) - 100*k
)
m.solve(disp=False)
profit = (300*q2.value[0] - 175*((q2.value[0]**2)/k.value[0]) - 100*k.value[0])
l2 = q2.value[0]**2/k.value[0]
```

### This gives us the following solutions 
(note that I'm rounding here)

```{python}
#| slideshow: {slide_type: fragment}
print('q2     ', int(q2.value[0]))
print('l2     ',int(l2))
print('K      ', int(k.value[0]))
print('profit ', int(profit))
```

### Optimal production plan for both:
Let's refer to the prices as "P", and the labor and capital costs as "C"
$$ \Pi(P,C) \equiv 275 \times q_1 + 300 \times q_2 - 140 \times L_1 - 175 \times L_2 - 100 \times K $$
$$ q_1 \leq \sqrt{L_1 \times K} $$
$$ q_2 \leq \sqrt{L_2 \times K} $$
$$ K \leq \bar{K} = 200 $$

Again both constraints allow us to eliminate $L$:
$$ \Pi(P,C) \equiv 275 \times q_1 + 300 \times q_2 - 140 \times \frac{q_1^2}{K} - 175 \times \frac{q_2^2}{K} - 100 \times K $$
$$ K \leq \bar{K} = 200 $$

```{python}
#| slideshow: {slide_type: subslide}
# reset gekko
m = GEKKO(remote=False)
# Initialize the decision variables with guesses for the optimizer
q1 = m.Var(name="q1", lb=0)
q1.value=1
q2 = m.Var(name="q2", lb=0)
q2.value=1
k =  m.Var(name="k", lb=0, ub=200) 
k.value=200
```

```{python}
#| slideshow: {slide_type: subslide}
# write the objective function  and solve
m.Maximize(
    275*q1 - 140*((q1**2)/k)
    + 300*q2 - 175*((q2**2)/k)
    - 100*k
)
m.solve(disp=False)
```

```{python}
#| slideshow: {slide_type: subslide}
# quick calcs to clean things up
profit = (
    275*q1.value[0] - 140*((q1.value[0]**2)/k.value[0]) 
    + 300*q2.value[0] - 175*((q2.value[0]**2)/k.value[0])  
    - 100*k.value[0]
)
l1 = q1.value[0]**2/k.value[0]
l2 = q2.value[0]**2/k.value[0]
```

### This gives us the following solutions 
(note that I'm rounding here)

```{python}
#| slideshow: {slide_type: fragment}
print('q1     ', int(q1.value[0]))
print('l1     ',int(l1))
print('q2     ', int(q2.value[0]))
print('l2     ',int(l2))
print('K      ', int(k.value[0]))
print('profit ', int(profit))
```

### We always pick k=200. What does this mean?

- This means that the capital constraint is preventing us from making the next unit of output.
- When a constraint does this we often call it a 'binding constraint'.

### The q1,L1 and q2,L2 pairs that we pick are the same when we consider the products separately and together. What does this mean?

- It means that the profit function is __separable__ when the capital constraint is binding.

### Repeat all three steps with $P_1=200$

```{python}
#| slideshow: {slide_type: fragment}
m = GEKKO(remote=False)
q1 = m.Var(name="q1", lb=0)
q1.value=1
q2 = m.Var(name="q2", lb=0)
q2.value=1
k =  m.Var(name="k", lb=0, ub=200)
k.value=200 
m.Maximize(
    200*q1 - 140*((q1**2)/k) - 100*k
)
m.solve(disp=False) # silencing the out put because it is diagnostic
profit = (
    200*q1.value[0] 
    - 140*((q1.value[0]**2)/k.value[0]) 
    - 100*k.value[0]
)
l1 = q1.value[0]**2/k.value[0]
```

###  $Q_1$ when $P_1=200$

```{python}
print('q1     ', int(q1.value[0]))
print('l1     ', int(l1))
print('K      ', int(k.value[0]))
print('profit ', int(profit))
```

### The optimal amount of Q1 to produce is 0.

What does this mean?

What does this mean?
This means that a firm that only produces Q1 should not produce it at this price, given this cost structure.
What does this mean for a firm that produces Q2? 
What should they do? enter the market for Q1 or not?

### Lets look at the profit functions for the two single product firms with k=200

```{python}
# set up
def Pi1(q1):
    return 200*q1 - 140*((q1**2)/200) 
def Pi2(q2):
    return 300*q2 - 175*((q2**2)/200) 
q1=np.linspace(0,300,300)
q2=np.linspace(0,300,300)

Pq1=Pi1(q1)- 100*200
Pq2=Pi2(q2)- 100*200
```

```{python}
#| slideshow: {slide_type: subslide}
# plot so we can see what is going on
plt.plot(q1,Pq1,label='Profit (q1)')
plt.plot(q1,Pq2,label='Profit (q2)')
plt.xlabel('Quantity')
plt.legend()
plt.grid()
plt.axhline(0, color='grey')
plt.title('Profit with k=200 and P1=200')
plt.show()
```

###  $Q_1$ and $Q_2$ when $P_1=200$ 
Now we are back to the multiproduct firm

```{python}
#| slideshow: {slide_type: subslide}
# Let's look at the two together
# reset gekko
m = GEKKO(remote=False)
# Initialize the decision variables
q1 = m.Var(name="q1", lb=0)
q1.value=1
q2 = m.Var(name="q2", lb=0)
q2.value=1
k =  m.Var(name="k", lb=0, ub=200) # this is the constraint
k.value=200 # this is our first guess to speed up the solution
m.Maximize(
    200*q1 - 140*((q1**2)/k)
  + 300*q2 - 175*((q2**2)/k)
  - 100*k
)
m.solve(disp=False)
profit = (
    200*q1.value[0] - 140*((q1.value[0]**2)/k.value[0]) 
  + 300*q2.value[0] - 175*((q2.value[0]**2)/k.value[0])  
  - 100*k.value[0]
)
l1 = q1.value[0]**2/k.value[0]
l2 = q2.value[0]**2/k.value[0]
```

```{python}
#| slideshow: {slide_type: subslide}
print('q1     ', int(q1.value[0]))
print('l1     ', int(l1))
print('q2     ', int(q2.value[0]))
print('l2     ', int(l2))
print('K      ', int(k.value[0]))
print('profit ', int(profit))
```

### Lets plot this and see what it's telling us.

```{python}
#| slideshow: {slide_type: '-'}
# Create data for the plot
def bigPi(q1,q2,k=200):
    return 200*q1 - 140*((q1**2)/k)+ 300*q2 - 175*((q2**2)/k) - 100*k
q1=np.linspace(0,300,300)
q2=np.linspace(0,300,300)
Q1, Q2 = np.meshgrid(q1, q2)
Pi12 = bigPi(Q1,Q2)
```

```{python}
#| slideshow: {slide_type: subslide}
# Create the figure and add a 3D axis
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
# Plot the data
ax.plot_surface(Q1, Q2, Pi12)
# Set axis labels and show the plot
ax.set_xlabel('Q1')
ax.set_ylabel('Q2')
ax.set_zlabel('Profit')
plt.show()
```

__Notice that alot of this profit graph is below zero!__

### Let's zoom to the zero lower bound

```{python}
Profit =  np.where(Pi12>0,Pi12,np.nan)
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(Q1, Q2, Profit)
ax.set_xlabel('Q1')
ax.set_ylabel('Q2')
ax.set_zlabel('Profit')
plt.show()
```

- These are the profitable production plans, and the one at the top is the optimal plan.

 ### What interesting insights or questions jump out from these facts?

- Now there is some synergy!
- The functions are no longer separable
 
## Why is this? What is going on?

- This is what it means to share capital. 

## What are scenarios where this would play out in the real world? 

- Adding a second product that does not compete with the first but that can be made using the same machines?
- A manufacturing firm takes on additional work with idle capacity. 
- A retail firm adding a product line.
 

## Now let's fill in the marginal cost table

#### For each of these the first step is to see how much K we need given the production choices.
_BTW, we are going to use a one unit increment here, but something less is fine i.e. true marginal cost._

| $q_1$ | $q_2$ | MC of $q_1$ with $q_2$ fixed. | MC of $q_2$ with $q_1$ fixed. |
|:-----:|:-----:|:-----------------------------:|:-----------------------------:|
|   50  |   50  |                               |                               |
|   50  |  100  |                               |                               |
|   50  |  150  |                               |                               |
|  100  |   50  |                               |                               |
|  100  |  100  |                               |                               |
|  100  |  150  |                               |                               |
|  150  |  100  |                               |                               |
|  150  |  150  |                               |                               |

We are going to take the q as given and then calculate the optimal K for each and then increment.

## First, put the data into a dictionary

```{python}
#| slideshow: {slide_type: fragment}
import pandas as pd
dd = {
    'q1': [50, 50, 50,100,100,100,150,150],
    'q2': [50,100,150, 50,100,150,100,150]
}
```

### Second, write down the functions

```{python}
#| slideshow: {slide_type: fragment}
def findK(q1,q2):
    m = GEKKO(remote=False)
    # Initialize the decision variablesc
    k =  m.Var(name="k", lb=0, ub=200) # this is the constraint
    k.value=200 # this is our first guess to speed up the solution
    m.Maximize(
        275*q1 - 140*((q1**2)/k)
        + 300*q2 - 175*((q2**2)/k)
        - 100*k
    ) 
    m.solve(disp=False)
    return k.value[0]
```

```{python}
#| slideshow: {slide_type: subslide}
def labor(q,K):
    return (q**2)/K
```

```{python}
#| slideshow: {slide_type: subslide}
def cost(L1,L2,K):
    return 140*L1 + 175*L2 + 100*K
```

```{python}
#| slideshow: {slide_type: fragment}
findK(50,50)
```

### Fill in the baseline table for each set of points

```{python}
#| slideshow: {slide_type: fragment}
df = pd.DataFrame(dd)
df['K']=np.vectorize(findK)(df['q1'],df['q2'])
df['L1'] = np.vectorize(labor)(df['q1'],df['K'])
df['L2'] = np.vectorize(labor)(df['q2'],df['K'])
df['Cost'] = np.vectorize(cost)(df['L1'],df['L2'],df['K'])
df
```

### Now increment q1 by 1

```{python}
#| slideshow: {slide_type: fragment}
df_i_q1 = pd.DataFrame(dd)
df_i_q1['q1']=df_i_q1['q1']+1
df_i_q1['K']=np.vectorize(findK)(df_i_q1['q1'],df_i_q1['q2'])
df_i_q1['L1'] = np.vectorize(labor)(df_i_q1['q1'],df_i_q1['K'])
df_i_q1['L2'] = np.vectorize(labor)(df_i_q1['q2'],df_i_q1['K'])
df_i_q1['Cost'] = np.vectorize(cost)(df_i_q1['L1'],df_i_q1['L2'],df_i_q1['K'])
df_i_q1
```

### Now increment q2 by 1

```{python}
#| slideshow: {slide_type: fragment}
df_i_q2 = pd.DataFrame(dd)
df_i_q2['q2']=df_i_q2['q2']+1
df_i_q2['K']=np.vectorize(findK)(df_i_q2['q1'],df_i_q2['q2'])
df_i_q2['L1'] = np.vectorize(labor)(df_i_q2['q1'],df_i_q2['K'])
df_i_q2['L2'] = np.vectorize(labor)(df_i_q2['q2'],df_i_q2['K'])
df_i_q2['Cost'] = np.vectorize(cost)(df_i_q2['L1'],df_i_q2['L2'],df_i_q2['K'])
df_i_q2
```

# Marginal cost of q1 at each point

```{python}
df_i_q1['mc_q1'] = df_i_q1['Cost']-df['Cost']
df_i_q1
```

# Marginal cost of q2 at each point

```{python}
df_i_q2['mc_q2'] = df_i_q2['Cost']-df['Cost']
df_i_q2
```

__BUT WAIT! Dr. Morris this last one is really hard in Excel! :(__

... part of what I'm trying to do is show you Excel's limits :]

... I won't ask you to do that part on the exam!

